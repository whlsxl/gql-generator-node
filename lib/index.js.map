{"version":3,"sources":["../src/index.js"],"names":["generateQuery","field","rootField","skeleton","rootSkeleton","kind","depthLimit","dedupe","getFieldArgsDict","generateQueryRecursive","parentName","argumentsDict","duplicateArgCounts","crossReferenceKeyList","curDepth","path","curType","type","ofType","queryStr","childQuery","getFields","crossReferenceKey","name","indexOf","push","children","Object","entries","skeletonKeys","keys","filter","key","map","childField","concat","cur","join","repeat","args","length","dict","assign","astNode","types","getTypes","indent","fragIndent","forEach","unionChildQuery","wrapQueryIntoKindDeclaration","alias","queryResult","varsToTypesStr","query","toLowerCase","generateAll","schema","result","QUERY_KINDS_MAP","Query","Mutation","Subscription","addToResult","obj","description","moduleConsole","warn","String","getMutationType","getQueryType","getSubscriptionType"],"mappings":"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","sourcesContent":["#!/usr/bin/env node\n\nimport {\n  getArgsToVarsStr,\n  getFieldArgsDict,\n  getVarsToTypesStr,\n  moduleConsole,\n} from \"./utils\";\n\n/**\n * Generate the query for the specified field\n * @param field executable schema representative\n * @param rootSkeleton Object representation of fields in interest\n * @param kind of query - Actual Query or Mutation, Subscription\n * @param depthLimit\n * @param dedupe function to resolve query variables conflicts\n */\nexport const generateQuery = ({\n  field: rootField,\n  skeleton: rootSkeleton,\n  kind = \"Query\",\n  depthLimit,\n  dedupe = getFieldArgsDict,\n}) => {\n  /**\n   * Generate the query for the specified field\n   * @param field executable schema representative\n   * @param skeleton Object representation of fields in interest\n   * @param parentName parent name of the current field\n   * @param argumentsDict dictionary of arguments from all fields\n   * @param duplicateArgCounts map for deduping argument name collisions\n   * @param crossReferenceKeyList list of the cross reference\n   * @param curDepth current depth of field\n   * @param path\n   */\n  const generateQueryRecursive = ({\n    field,\n    skeleton,\n    parentName,\n    argumentsDict = {},\n    duplicateArgCounts = {},\n    crossReferenceKeyList = [], // [`${parentName}To${curName}Key`]\n    curDepth = 1,\n    path = [],\n  }) => {\n    let curType = field.type;\n    while (curType.ofType) curType = curType.ofType;\n\n    let queryStr = \"\";\n    let childQuery = \"\";\n\n    if (curType.getFields) {\n      const crossReferenceKey = `${parentName}To${field.name}Key`;\n      if (\n        crossReferenceKeyList.indexOf(crossReferenceKey) !== -1 ||\n        curDepth > depthLimit\n      )\n        return \"\";\n      crossReferenceKeyList.push(crossReferenceKey);\n      const children = curType.getFields();\n      childQuery = Object.entries(children);\n      if (skeleton) {\n        const skeletonKeys = Object.keys(skeleton);\n        childQuery = childQuery.filter(\n          ([key]) => skeletonKeys.indexOf(key) !== -1\n        );\n      } else skeleton = {};\n      childQuery = childQuery\n        .map(\n          ([key, childField]) =>\n            generateQueryRecursive({\n              field: childField,\n              skeleton: skeleton[key],\n              parentName: field.name,\n              argumentsDict,\n              duplicateArgCounts,\n              crossReferenceKeyList,\n              curDepth: curDepth + 1,\n              path: path.concat(field.name),\n            }).queryStr\n        )\n        .filter((cur) => cur)\n        .join(\"\\n\");\n    }\n\n    if (!(curType.getFields && !childQuery)) {\n      queryStr = `${\"    \".repeat(curDepth)}${field.name}`;\n      if (field.args.length > 0) {\n        const dict = dedupe(field, duplicateArgCounts, argumentsDict, path);\n        Object.assign(argumentsDict, dict);\n        queryStr += `(${getArgsToVarsStr(dict)})`;\n      }\n      if (childQuery) {\n        queryStr += `{\\n${childQuery}\\n${\"    \".repeat(curDepth)}}`;\n      }\n    }\n\n    /* Union types */\n    if (curType.astNode && curType.astNode.kind === \"UnionTypeDefinition\") {\n      const types = curType.getTypes();\n      if (types && types.length) {\n        const indent = `${\"    \".repeat(curDepth)}`;\n        const fragIndent = `${\"    \".repeat(curDepth + 1)}`;\n        queryStr += \"{\\n\";\n\n        types.forEach((type) => {\n          let unionChildQuery = Object.entries(type.getFields());\n          if (skeleton && Object.keys(skeleton).length) {\n            const skeletonKeys = Object.keys(skeleton);\n            unionChildQuery = unionChildQuery.filter(\n              ([key]) => skeletonKeys.indexOf(key) !== -1\n            );\n          } else skeleton = {};\n          unionChildQuery = unionChildQuery\n            .map(\n              ([key, childField]) =>\n                generateQueryRecursive({\n                  field: childField,\n                  skeleton: skeleton[key],\n                  parentName: field.name,\n                  argumentsDict,\n                  duplicateArgCounts,\n                  crossReferenceKeyList,\n                  curDepth: curDepth + 2,\n                  path: path.concat(field.name),\n                }).queryStr\n            )\n            .filter((cur) => cur)\n            .join(\"\\n\");\n          queryStr += `${fragIndent}... on ${type.name} {\\n${unionChildQuery}\\n${fragIndent}}\\n`;\n        });\n        queryStr += `${indent}}`;\n      }\n    }\n    return { queryStr, argumentsDict };\n  };\n\n  return wrapQueryIntoKindDeclaration(\n    kind,\n    rootField,\n    generateQueryRecursive({\n      field: rootField,\n      skeleton: rootSkeleton,\n      parentName: kind,\n    })\n  );\n};\n\nfunction wrapQueryIntoKindDeclaration(kind, alias, queryResult) {\n  const varsToTypesStr = getVarsToTypesStr(queryResult.argumentsDict);\n  const query = queryResult.queryStr;\n  return `${kind.toLowerCase()} ${alias.name}${\n    varsToTypesStr ? `(${varsToTypesStr})` : \"\"\n  }{\\n${query}\\n}`;\n}\n\nexport function generateAll(\n  schema,\n  depthLimit = 100,\n  dedupe = getFieldArgsDict\n) {\n  const result = {};\n\n  const QUERY_KINDS_MAP = {\n    Query: \"queries\",\n    Mutation: \"mutations\",\n    Subscription: \"subscriptions\",\n  };\n\n  /**\n   * Generate the query for the specified field\n   * @param obj one of the root objects(Query, Mutation, Subscription)\n   * @param description description of the current object\n   */\n  const addToResult = (obj, description) => {\n    const kind =\n      QUERY_KINDS_MAP[description] ||\n      moduleConsole.warn(`unknown description string: ${description}`) ||\n      `${String(description).toLowerCase()}s`;\n    result[kind] = {};\n    Object.entries(obj).forEach(([type, field]) => {\n      result[kind][type] = generateQuery({\n        field,\n        parentName: description,\n        depthLimit,\n        dedupe,\n        kind: description,\n      });\n    });\n  };\n\n  if (schema.getMutationType()) {\n    addToResult(schema.getMutationType().getFields(), \"Mutation\");\n  } else {\n    moduleConsole.warn(\"No mutation type found in your schema\");\n  }\n\n  if (schema.getQueryType()) {\n    addToResult(schema.getQueryType().getFields(), \"Query\");\n  } else {\n    moduleConsole.warn(\"No query type found in your schema\");\n  }\n\n  if (schema.getSubscriptionType()) {\n    addToResult(schema.getSubscriptionType().getFields(), \"Subscription\");\n  } else {\n    moduleConsole.warn(\"No subscription type found in your schema\");\n  }\n\n  return result;\n}\n"],"file":"index.js"}